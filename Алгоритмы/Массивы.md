**Массив** - структура данных состоящая из набора однотипных переменных, доступ к которым осуществляется по индексу. Динамический массив может изменять свой размер в зависимости от количества элементов в нем.

**Концепция:**
**Элемент** - это любой элемент, хранящийся в массиве.
**Индекс** - это числовой индекс, использующийся для идентификации элемента в массиве. У каждого элемента он свой.

**Операции:**
**add** - вставка элемента на позицию с заданным индексом. Время выполнения - O(1), в худшем случае O(N), когда нужно перенести все элементы из одного массива в другой (например, во время расширения динамического массива)
**get** - получить элемент массива по индексу. Время выполнения - O(1)
**set** - по индексу записать элемента (перезаписать, не путать с добавлением). Время выполнения O(1)
**del** - удаление элемента с заданным индексом. в худшем O(N)

# Поиск в отсортированном массиве (бинарный поиск) (легко)

**Алгоритм решения:**
1) Делим массив на 2 части и находим серидину массива
2) Сравниваем элемент из серидины с искомым значением
	1) Если элемент искомый, то вы у нас результат
	2) Если элемент меньше искомого, то повторяем алгоритм для правой части
	3) Если алгоритм меньше искомого, то повторяем для левой части

**Условия** - Список должен быть отсортирован

**Реализация на Go**

```
func search(nums []int, target int) int {
    left := 0
    right := len(nums) - 1
    
    for left <= right {
        mid := (right + left) / 2
        if nums[mid] == target {
            return mid
        } 

        if nums[mid] < target {
            left = mid + 1
        }

        if nums[mid] > target {
            right = mid - 1
        }
    }

    return -1
}
```

**Задачи:**
1) https://leetcode.com/problems/binary-search/

# Удаление элемента из массива (Легко)
Удаление из массива элемента без использования дополнительной памяти фактически является перестановкой элементов массива.

**Алгоритм решения:**
1) Создаем указатель на новый "хвост" массива
2) Проходимся по каждому элементу массива и проверяем значение с искомым
	1) Если значение не найдено, то по индексу нового "хвоста", вставляем текущее значени и увеличиваем значение индекса "хвоста"
	2) Если значение найдено, то пропускаем итерацию - ничего не делаем

**Решение на Go:**
```
func removeElement(nums []int, val int) int {
    if len(nums) == 0 {
        return 0
    }

    tail := 0
    for _, v := range nums {
        if val != v {
            nums[tail] = v
            tail++
        }
    }

    return tail
}
```

**Задачи:**
1) https://leetcode.com/problems/remove-element/

# Удаление дублей из отсортированного массив (легко)

**Алгоритм решения:**
1) Создаем указатель на новый "хвост" массива
2) Проходим по каждому элементу массива, начиная со второго и проверяем элемент с тем что лежим под индексом "хвоста"
	1) Если значения не совпадает, то увеличиваем "хвост" и вставляем по индексу нового "хвоста" текущее значения
	2) Если значения совпадают, то пропускаем итерацию - ничего не делаем
3) В конце алгоритма "хвост" инкрементим, так как мы работали с индесом, а нам нужна длина нового массива

**Решение на Go:**
```
func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    tail := 0
    for _, v := range nums[1:] {
        if nums[tail] != v {
            tail++
            nums[tail] = v
        }
    }
    return tail++
}
```

**Задачи:**
1) https://leetcode.com/problems/remove-duplicates-from-sorted-array/

# Two Sum (легко)
**Алгоритм решения через hash таблицу:**
1) Проходим по массиву элементов
2) Для каждого элемента считаем разницу **n** между искомым значеним и текущим (вычисляем число, которое в сумме с текущим элементом даст искомое значени)
3) Проверяем есть ли в хештаблице по ключу **n** значение
	1) Если есть, печатаем 2 индекса - текущий индекс цикла и значение из хештаблицы
	2) Если значения нет, то записываем в хештаблицу ключ - текущее значение, значение - текущий индекс

**Особенности:**
1) работает за O(N)
2) требуем O(N) памяти
3) не требует отсортированного массива

**Реализация на Go:**
```
func twoSum(nums []int, target int) []int {
    h := make(map[int]int, 0)
    for i, v := range nums {
        n := target - v
        if i2, ok := h[n]; ok {
            return []int{i, i2}
        }
        h[v] = i
    }
    return nil
}
```

**Алгоритм решения через 2 указателя:**
1) Определяем 2 указателя на начало и конец массива
2) На каждой итерации цикла проверяем сумму двух элементов под этими указателями
	1) Если сумма совпадает с искомым - то это ответ
	2) Если сумма больше искомового значения - то двигаем указатель на конец
	3) Если сумма меньше искомово значения - то двигаем указатель на начало

**Особенности:**
1) работает за O(N)
2) не требует доп памяти
3) требует отсортированного массива

**Реализация на Go:**
```
func twoSum(numbers []int, target int) []int {
    right := 0
    left := len(numbers) - 1
    for right < left {
        sum := numbers[right] + numbers[left]
        if sum == target {
            return []int{right, left}
        }
        if sum > target {
            left--
            continue
        }
        if sum < target {
            right++
            continue
        }
    }

    return []int{}
}
```

**Задачи:**
1) https://leetcode.com/problems/two-sum/
2) https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/