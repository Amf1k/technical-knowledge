**Массив** - структура данных состоящая из набора однотипных переменных, доступ к которым осуществляется по индексу. Динамический массив может изменять свой размер в зависимости от количества элементов в нем.

**Концепция:**
**Элемент** - это любой элемент, хранящийся в массиве.
**Индекс** - это числовой индекс, использующийся для идентификации элемента в массиве. У каждого элемента он свой.

**Операции:**
**add** - вставка элемента на позицию с заданным индексом. Время выполнения - O(1), в худшем случае O(N), когда нужно перенести все элементы из одного массива в другой (например, во время расширения динамического массива)
**get** - получить элемент массива по индексу. Время выполнения - O(1)
**set** - по индексу записать элемента (перезаписать, не путать с добавлением). Время выполнения O(1)
**del** - удаление элемента с заданным индексом. в худшем O(N)

# Поиск в отсортированном массиве (бинарный поиск) (легко)

**Алгоритм решения:**
1) Делим массив на 2 части и находим серидину массива
2) Сравниваем элемент из серидины с искомым значением
	1) Если элемент искомый, то вы у нас результат
	2) Если элемент меньше искомого, то повторяем алгоритм для правой части
	3) Если алгоритм меньше искомого, то повторяем для левой части

**Условия** - Список должен быть отсортирован

**Реализация на Go**

```
func search(nums []int, target int) int {
    left := 0
    right := len(nums) - 1
    
    for left <= right {
        mid := (right + left) / 2
        if nums[mid] == target {
            return mid
        } 

        if nums[mid] < target {
            left = mid + 1
        }

        if nums[mid] > target {
            right = mid - 1
        }
    }

    return -1
}
```

**Задачи:**
1) https://leetcode.com/problems/binary-search/

# Удаление элемента из массива (Легко)
Удаление из массива элемента без использования дополнительной памяти фактически является перестановкой элементов массива.

**Алгоритм решения:**
1) Создаем указатель на новый "хвост" массива
2) Проходимся по каждому элементу массива и проверяем значение с искомым
	1) Если значение не найдено, то по индексу нового "хвоста", вставляем текущее значени и увеличиваем значение индекса "хвоста"
	2) Если значение найдено, то пропускаем итерацию - ничего не делаем

**Решение на Go:**
```
func removeElement(nums []int, val int) int {
    if len(nums) == 0 {
        return 0
    }

    tail := 0
    for _, v := range nums {
        if val != v {
            nums[tail] = v
            tail++
        }
    }

    return tail
}
```

**Задачи:**
1) https://leetcode.com/problems/remove-element/

# Удаление дублей из отсортированного массив (легко)

**Алгоритм решения:**
1) Создаем указатель на новый "хвост" массива
2) Проходим по каждому элементу массива, начиная со второго и проверяем элемент с тем что лежим под индексом "хвоста"
	1) Если значения не совпадает, то увеличиваем "хвост" и вставляем по индексу нового "хвоста" текущее значения
	2) Если значения совпадают, то пропускаем итерацию - ничего не делаем
3) В конце алгоритма "хвост" инкрементим, так как мы работали с индесом, а нам нужна длина нового массива

**Решение на Go:**
```
func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }

    tail := 0
    for _, v := range nums[1:] {
        if nums[tail] != v {
            tail++
            nums[tail] = v
        }
    }
    return tail++
}
```

**Задачи:**
1) https://leetcode.com/problems/remove-duplicates-from-sorted-array/

# Two Sum (легко)
**Алгоритм решения через hash таблицу:**
1) Проходим по массиву элементов
2) Для каждого элемента считаем разницу **n** между искомым значеним и текущим (вычисляем число, которое в сумме с текущим элементом даст искомое значени)
3) Проверяем есть ли в хештаблице по ключу **n** значение
	1) Если есть, печатаем 2 индекса - текущий индекс цикла и значение из хештаблицы
	2) Если значения нет, то записываем в хештаблицу ключ - текущее значение, значение - текущий индекс

**Особенности:**
1) работает за O(N)
2) требуем O(N) памяти
3) не требует отсортированного массива

**Реализация на Go:**
```
func twoSum(nums []int, target int) []int {
    h := make(map[int]int, 0)
    for i, v := range nums {
        n := target - v
        if i2, ok := h[n]; ok {
            return []int{i, i2}
        }
        h[v] = i
    }
    return nil
}
```

**Алгоритм решения через 2 указателя:**
1) Определяем 2 указателя на начало и конец массива
2) На каждой итерации цикла проверяем сумму двух элементов под этими указателями
	1) Если сумма совпадает с искомым - то это ответ
	2) Если сумма больше искомового значения - то двигаем указатель на конец
	3) Если сумма меньше искомово значения - то двигаем указатель на начало

**Особенности:**
1) работает за O(N)
2) не требует доп памяти
3) требует отсортированного массива

**Реализация на Go:**
```
func twoSum(numbers []int, target int) []int {
    right := 0
    left := len(numbers) - 1
    for right < left {
        sum := numbers[right] + numbers[left]
        if sum == target {
            return []int{right, left}
        }
        if sum > target {
            left--
            continue
        }
        if sum < target {
            right++
            continue
        }
    }

    return []int{}
}
```

**Задачи:**
1) https://leetcode.com/problems/two-sum/
2) https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/

# Максимальное/среднее/минимальное подмассива (Легко)

Поиск максимальной суммы или среднего для подмассива заданной длины. Решение выполняется при помощи метода скользящего окна.

**Алгоритм:**
1) Считаем сумму первых элементов до **k** - это будет наше первое окно
2) Проходимся по массиву с **k-того** элемента до конца
3) Считаем новую сумму - вычитаем из суммы элемент по индексу - текущий индекс цикла - **k** и добавляем элемент по индексу **i**
4) Проверяем новую сумму - больше максимуму или нет

**Реализация на Go:**
```
func findMaxAverage(nums []int, k int) float64 {
    sum := 0;
    for i:=0;i<k;i++ {
        sum += nums[i]
    }

    max := sum

    for i:=k;i<len(nums);i++ {
        sum = sum - nums[i-k] + nums[i]
        if sum > max {
            max = sum
        }
    }

    return float64(max) / float64(k)
}
```

**Задачи:**
1) https://leetcode.com/problems/maximum-average-subarray-i/

# Возведение массива в квадрат
Суть задания в том, что бы возвести все числа массива в квадрат и отсортировать их по аналогии с исходным массивов. Допустим у нас есть массив [-4,-1,0,3,10] и на выходе получаем [0,1,9,16,100].

**Алгоритм решения:**
1) Создаем два указателя на массив - один на начало массива, другой на конец массива
2) Итерируемся с обратным индексом
3) На каждой итерации проверяем абсолютные величины элементов под двумя указателями
	1) Если под левым указателем лежит абсолютное значение меньше, то делаем квадрат правого числа и записываем в новый массив по индексу цикла и уменьшаем правый указатель
	2) Если под левым указателем лежит абсолютное значение больше, то делаем квадрат левого числа и записываем в новый массив по индексу цикла и увеличиваем левый указатель

**Решение на Go:**
```
func sortedSquares(nums []int) []int {
    left, right := 0, len(nums)-1
    result := make([]int, len(nums))
    for i := len(nums)-1;i >= 0;i-- {
        if abs(nums[left]) < abs(nums[right]) {
            result[i] = nums[right] * nums[right]
            right--
        } else {
            result[i] = nums[left] * nums[left]
            left++
        }
    }

    return result
}

//В дурацком Go нет нормальный функции
func abs(x int) int {
    if x < 0 {
        return -x
    }

    return x
}
```

**Задачи:**
1) https://leetcode.com/problems/squares-of-a-sorted-array/